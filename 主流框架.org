* Spring
** 技巧
   1. 调试技巧
      1. Debugger -> Data Views -> Java
	 - 去掉勾选
	   1. Hide null elements in arrays and collections
	   2. Enable alternative view for Collecttions classes
	      HashMap 不显示 table
   2. 导入空间不显示
      在右上角检查语法图标选择 All Problem
** getBean("beanId") 执行流程
   1. 根据beanId，先在beanDefinmap里面查是不是单例的，如果是，就直接从singtonObject里面获取，如果不是，就创建
** xml如果不指定id，运行会不会报错
   不会，系统会默认分配id。分配id的规则是全类名#0，全类名#1，我们可以通过debug方式来查看
** 创建bean对象
   1. 通过类型来获取bean对象
      ioc.getBean(Monster.class)
      前提：要求ioc容器中的同一个类的bean只能有一个，否则会抛出异常 NoUniqueBeanDefinitionException
** Bean创建顺序
   1. 在spring的ioc容器，默认是按照配置的顺序创建bean对象
   2. 如果配置 depends-on="bean id"，被依赖的对象会先创建
   3. 如果有ref，也还是按照配置的顺序创建，但ref的对象的引用关系是在创建对象之后，这样才不会造成空引用
** Bean的单例和多实例
   默认是按照单例创建的，配置以多实例创建：scope="prorotype"
   - 使用细节
     1. 默认是单例singleton,在启动容器时，默认就会创建，并放入到singletonObjects集合
     2. 当<bean scope="prototype">设置为多实例机制后，该bean是在getBean()时才创建
     3. 如果是单例singleton,同时希望在getBean时才创建，可以指定懒加载lazy-init="true"(注意默认是false)
     4. 通常情况下,lazy-init就使用默认值false,在开发看来,用空间换时间是值得的，除非有特殊的要求
     5. 如果scope="prototype"，这时你的lazy-init属性的值不管是ture，还是false都是在getBean时候，才创建对象。
** Bean的生命周期
   1. init-method="init" 指定bean的初始化方法，在setter方法后执行
   2. destroy-method="destroy" 指定bean的销毁方法，在容器关闭的时候执行
      1. 关闭容器
	 ((ConfigurableApplicationContext)ioc).close();
   3. 方法名可以是任意的
** 配置bean后置处理器
   该处理器会在bean初始化方法调用前和初始化方法调用后被调用
   1. implements BeanPostPrcessor {} 就是后置处理器
   2. postProcessBeforeInitialization(Object bean, String beanName)
      1. bean
	 传入的在IOC容器中创建的bean
      2. beanName
	 传入的在IOC容器中创建的bean的id
   3. xml和配置普通bean方式相同
** 给bean注入属性
1. Spring底层给bean对象属性赋值使用的是setter方法
   1. 通过构造器给属性赋值
      <constructor-arg value="200" index="0"/>
      1. index表式构造器的第几个参数，从0开始计算的
      2. 除了可以通过index还可以通过 name / type来指定参数方式
      3. 类的构造器，不能有完全相同类型和顺序的构造器，所以可以通过type来指定
   2. 通过p名称空间给属性赋值
      p:monsterId="500"
2. 使用utillist进行配置
   用来保存一个list，达到数据复用
   1. <util:list id="myBookList"> 多个value标签 </util:list>
   2. 通过 ref="myBookList" 引用
   3. 在使用util:list名称空间的时候，需要引入相应的标签，一般来说通过alt+enter会自动加入，如果没有就手动添加一下
3. 属性级联赋值配置
   spring的ioc容器，可以直接给对象属性的属性赋值，即级联属性赋值
   1. 先引用
      <property name-"dept" ref="dept"/>
   2. 再给属性赋值
      <property name-"dept.name" value="Jave开发部门"/>
      底层会调用setter方法
4. 通过静态工厂获取bean
   bean id class="" factory-method="静态方法" > constructor-arg value="参数"
   1. class是静态工厂类的全路径
   2. factory-method表示是指定静态工厂类的哪个方法返回对象
   3. constructor-arg value="monster02" value是指定要返回静态工厂的哪个对象
5. 通过实例工厂获取bean
   首先需要有实例对象
   bean id factory-bean="实例id" factory-method="实例方法" > constructor-arg="参数"
6. 重点：通过FactoryBean获取bean
   1. MyFactoryBean implements FactoryBean<Monster>
      1. 定义属性 key monster_map
      2. 代码块中给 monster_map 填充数据
      3. 实现 getObject getObjectType isSingleton 方法
   2. xml
      bean id class="FactoryBean的全类名" > property name="key的变量名" value="key的值"
7. bean配置信息重用
   1. parent-"要继承的bean id"
   2. 这样就不需要给属性赋值
   3. 如果一个bean指定了 abstract="true"，表明了这个bean只能被继承
8. 通过属性文件配置bean
   1. 创建 my.properties
   2. context:property-placeholder location="classpath:myproperties"
   3. ${属性文件的key}
   4. 属性文件如果有中文会乱码，解决方式：由于文件在读取到内存中使用的是unicode，使用中文的 unicode 编码
9. 自动装配bean
   给引用属性初始化的另一种方法
   1. autowire="byType"
      通过类型的方式给对象属性，自动完成赋值
      1. 根据bean的引用类型，在容器中去找有没有该类型的bean，会按照类型自动装配
      2. 要求：不能有两个这样的bean
   2. autowire="byName"
      通过名字完成自动装配
      1. 根据bean的引用变量名的setXxx()的xxx，在容器中去找有没有该xxx名字的bean
      2. 是按照setter名来装配的，因为底层是用反射进行装配的，反射是通过方法来完成的
** 注解
1. xml
   context:component-scan base_package="包的全路径"
   1. 排除某个注解
      context:component-scan > context:exclude-filter type="annotation" expression="注解的全路径"
   2. 指定自动扫描哪些注解类
      context:component-scan use-default-filters="false" > context:include-filter type="annotation" expression="注解的全路径"
      1. use-default-filters="false"
	 取消默认过滤机制
2. 注解配置bean注意事项和细节
   1. 默认情况：类名首字母小写作为id，也可以使用注解的value属性指定id值，并且value可以省略
3. 自动装配
   1. @Autowired
      在ioc容器，根据实例的个数选择按类型，或者是按属性名装配
      1. 在IOC容器中查找待装配的组件的类型，如果有唯一的bean匹配，则使用该bean装配
      2. 如果有多个，就以属性名作为id去匹配
   2. @Resource(name="xxx")
      1. name="xxx"
	 表示装配id=xxx的对象
      2. type = xxx.class
	 表示按照xxx.class类型进行装配，这时要求容器中，只能有一个这样类型的对象
      3. 如果@Resource没有指定name 和 type,则先使用byName注入策略, 如果匹配不上，再使用byType莱略，如果都不成功，就会报错
   3. @Autowired 和 @Qualifier(value="xxx") 一起使用
      也可以按照id=xxx自动装配
4. 泛型依赖注入
   传统方法是将 PhoneDao / BookDao自动装配到 BookService/ PhoneSerive 中，当这种继承关系多时，就比较麻烦，可以使用spring提供的泛型依赖注入
   #+begin_src java
     // BaseService.java
     @Autowired
     private BaseDao<T> baseDao;
   #+end_src
   1. 在泛型类BaseService中，在一个带有泛型的属性上使用
   2. 这样BaseService的子类，即使没有装载BaseDao的子类，也可以使用BaseDao的子类对象
** 自己实现Spring注解配置Bean机制
1. 思路分析
   1. HspSpringConfig.java配置类
      作用类似beans.xml配置文件，用来指定扫描的包
   2. 该类会标识一个注解 @ComponentScan(value="com.xx.yy")
   3. HspSpringApplicationContext.java spring容器
      1. 传入 HspSpringConfig.class
2. 代码实现
   1. 搭建基本结构并获取扫描包
   2. 获取扫描包下的所有.class文件
   3. 获取全类名 反射对象 放入容器
3. 详细步骤
   1. 先拿到配置类的class
      HspSpringConfig.class
   2. 得到类的注解，进而获得value，也就是包的全类名path
      class对象.getDeclaredAnnotation(ComponentScan)
   3. 获取扫描包下的所有.class文件
      1. 扫描包目录 = 项目目录 + 包目录
      2. 得到类的加载器，因为项目目录是在out下
	 HspSpringApplicationContext.class.getClassLoader()
      3. 通过类的加载器获取到要扫描包的url
	 1. path = path.replace(".", "/")
	 2. =URL resource = classLoader.getResource(path)=
      4. 根据url，创建文件
	 new File(resource.getFile())
      5. 遍历文件，得到.class文件的绝对路径
      6. 获取每个类名，拼接包名，获得全类名
      7. 根据全类名，获得class对象 aClass
	 =Class<?> aClass = classLoader.loadClass(classFullName)= 不会调用静态方法
      8. 判断该类是否有4个注解
	 aClass.isAnnotionPresent(Component.class)
      9. 反射对象，并放入容器
	 1. =Class<?> clazz = Class.forName(classFullName)= 会调用静态方法
	 2. Object instance = clazz.newInstance()
** AOP
1. 动态代理
   一个接口的某个方法run()，几个不同类型的对象实现这个方法，执行run()方法时，有在执行这个方法之前、之后做一件事
   1. 给接口定义一个代理类
      Vehicle 接口 VehicleProxyProvider 代理类
   2. 定义属性
      private Vehicle target_vehicle;
      表示真正要执行的对象
   3. 编写一个方法 getProxy()，可以返回一个代理对象
      1. Object proxy = Proxy.newProxyInstance(classLoader, interfaces, invocationHandler)
	 1. target_vehicle.getClass().getInterfaces()
	    获得接口信息
	 2. invocationHandler是接口
	    invoke(object proxy, Method method, Object[] args)
	    1. proxy 表示代理对象
	    2. method 就是通过代理对象调用方法时，的哪个方法
	    3. invoke()返回值为，代理对象执行方法后的返回结果
*** 切面编程
切面类的方法可以根据需要切入到任意类的任意方法
1. 相关注解
   1. 前置通知：@Before
   2. 返回通知：@AfterReturning
      目标方法调用后
   3. 异常通知：@AfterThrowing
   4. 后置通知：@After
      相当于 finally 语句快，不管是否发生异常都会执行
   5. 环绕通知：@Around
2. xml
   <aop:aspectj-autoproxy/>
3. 切面类
   1. 类注解：@aspectj
   2. 方法注解
   3. 获取返回值
      @AfterReturning(return="res")
   4. 获取异常信息
      @AfterThrowing(throwing="throwable")
4. 细节
   1. 使用ioc.getBean()，获取注入的对象，需要以接口的类型来获取
   2. 通过debug，ioc容器里面还是原生的，一旦进行getBean，获取的就是代理对象，所以代理对象也可以通过id获取，但也需要转成接口类型
   3. 使用接口获取代理对象，实现接口的类不能有2个
      解决方法：通过名字来获取
5. 切入表达式细节
   1. 切入表达式也可以指向类的方法,这时切入表达式会对该类/对象生效
   2. 切入表达式也可以指向接口的方法,这时切入表达式会对实现了接口的类/对象生效
   3. 切入表达式也可以对没有实现接口的类，进行切入通过继承得到的代理对象
6. 切入表达式重用
   1. 定义一个切入点，在方法上加上 @PointCut(value="execution(切入表达式)")
   2. @Before(value="切入点方法名()")
7. 切面类执行顺序
   1. 切面类注解 @order(value=2)
   2. 值越小，优先级越高
*** 基于XML配置的AOP
* Spring底层
** xml文件位置
   1. 如果我们是普通的java项目，beans.xmt放在src下
   2. 如果我们是java maven 项目，beans.xml 放在 src/main/resources
** spring怎么实现一个注解 @Scope(value="prototype") 就能决定是单例，还是多例的，底层是如何实现的
** 加入 @Autowired Spring容器是如何实现依赖注入
** Spring 底层实现,如何实现Bean后置处理器机制
** 步骤
1. 配置类 -> ComponentScan注解 -> 扫描包
2. 完整的扫描包路径 = 项目路径 + 扫描包
3. 遍历文件 -> 过滤出class文件并提取类名与扫描包拼接 -> 创建class对象，并判断其注解是否包含 Component
* Spring底层
** 知识扩展：类加载器
1. Bootstrap类加载器
   对应路径jre/lib
2. Ext类加载器
   对应路径jre/lib/ext
3. App类加载器
   对应路径classpath
4. classpath类路径，就是java.exe执行时，通过-classpath 指定的路径
** 注意事项
1. maven项目beans.xml必须在resource
   因为项目目录是在target中
2. Spring的后置处理器中，如果想要修改bean，就返回修改后的bean
   =如果返回null并将bean没有置空，而是不改变bean=
3. 后置处理器在bean的初始化方法执行前后执行，bean的初始化方法名字任意，是在beans.xml中指定的，或者通过 @PostConstruct来指定
4. 如果没有初始化方法，后置处理器也会被调用
5. 后置处理器的配置
   1. xml 配置
   2. 注解配置：@component + 扫描包
6. aop的配置：扫描包 + 切面自动代理
** 任务1 编写自己Spring容器，实现扫描包，得到bean的class对象
*** 建立文件
1. component包建立注解类 Component ComponentScan
2. ioc包建立类 SpringConfig.java 替代bean.xml
3. ioc包建立类 SpringApplicationContext,java 作用类似于Spring原生ioc容器
   属性：Class configClass
*** 得到扫描包：@ComponentScan的值
#+begin_src java
  ComponentScan componentScan = (ComponentScan) this.configClass.getDeclaredAnnotation(ComponentScan.class);
  String path = componentScan.value();
#+end_src
*** 得到类加载器
#+begin_src java
  ClassLoader classLoader = SpringApplicationContext.class.getClassLoader();
#+end_src
*** 得到扫描包的完整路径
#+begin_src java
  path = path.replace(".", "/");
  URL resource = classLoader.getResource(path);
#+end_src
*** 遍历这个路径
#+begin_src java
  File file = new File( resource.getFile());
  if (file.isDirectory()){
      File[] files = file.listFiles();
      for (File f : files){}
  }
#+end_src
*** 只处理这个路径下的.class文件
#+begin_src java
  String fileAbsolutePath = f.getAbsoluttePath();
  if (fileAbsolutePath.endWith(".class")){
      
  }
#+end_src
*** 获取到类名
#+begin_src java
  String className = fileAbsolutePath.subString(fileAbsolutePath.lastIndexOf("\\") + 1, fileAbsolutePath.indexOf(".class"));
#+end_src
*** 获取到全类名
#+begin_src java
  String ClassFullname = path.replace("/", ".") + "." + className;
#+end_src
*** 根据全类名，创建classs对象
#+begin_src java
  Class<?> clazz = classLoader.loadClass(classFullName);
#+end_src
*** 判断注解是否有 @Compon
#+begin_src java
  if (clazz.isAnnotionPresent(Component.class)){}
#+end_src
** 任务2 将bean信息封装到 BeanDefinition对象，并放入到BeanDefinitionMap
包含单例对象集合和bean定义集合
1. annotation包增加注解 Scope
2. ioc包增加类 BeanDefinition
   - 包含的属性
     1. String scope
     2. Class clazz
	Bean对应的Class对象，为了反射可以生成对应的对象
3. SpringApplicationContext类增加属性
   1. ConcurrentHashMap<String, BeanDefinition> beanDefinitionMap
   2. ConcurrentHashMap<String, Object> singletonObjects
** 任务3 初始化bean单例池。并完成getBean方法，createBean方法
1. 独立的 createBean(BeanDefinition beanDefinition)方法 根据beanDefinition创建实例 跟是否在初始化单例池创建 是否在多实例时动态创建无关
   #+begin_src java
     Class clazz = beanDefinition.getClass();
     Object instance = clazz.getDeclaredConstructor().newInstance();
     return instance;
     // 失败返回空
     return null;
   #+end_src
2. getBean(String name)方法，对应spring的getBean()，使用反射得到实例
   #+begin_src java
     // 可以加一个判断，判断传入的beanName是否在beanDefinitionMap中存在
     if(beanDefinitionMap.containsKey(name)){
         BeanDefinition beanDefinition = beanDefinitionMap.get(name);
         if("singleton".equalsIgnoreCase(beanDefinition.getScope())){
     	return singletonObjects.get(name);
         } else{
     	return createBean(beanDefinition);
         }
     } else{
         // 抛出一个空指针异常
         throw new NullPointerException("没有该bean")
     }
   #+end_src
** 实现依赖注入，@Autowited是如何生效的
* SpringMVC
是WEB层框架，接管了Web层组件，比如控制器，视图，视图解析，不需要实现Servlet
** web.xml
tomcat的配置文件
#+begin_src xml
  <servlet>
    <servlet-name>springDispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!--配置属性 contextConfigLocation，指定DispatcherServlet 去操作的spring配置文件-->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:applicationContext-mvc.xml</param-value>
    </init-param>
    <!--在web项目启动时，就自动的加载DispatcherServlet-->
    <load-on-startup>1</load-on-startup>
  </servlet>
#+end_src
== 如果不指定spring容器配置文件，默认会从寻找/WEB-INF/springDispatcherServlet-servlet.xml，也就是 servlet-name-servlet==
* SpringMVC
** 快速入门
*** 配置中央控制器/前端控制器/分发控制器
web.xml
#+begin_src xml
  <servlet>
    <servlet-name>springDispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!--配置属性 contextConfigLocation，指定DispatcherServlet 去操作的spring配置文件-->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:applicationContext-mvc.xml</param-value>
    </init-param>
    <!--在web项目启动时，就自动的加载DispatcherServlet-->
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>springDispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
#+end_src
Spring的配置文件
#+begin_src xml
  <context:component-scan base-package=""/>
  <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/pages/"/>
    <property name="suffix" value=".jsp"/>
  </bean>
#+end_src
- 注意事项
  1. contextConfigLocation 如果没有指定，默认按照 springDispatcherServlet-servlet
** SpringMVC执行流程分析
1. 浏览器发出请求，到达前端控制器 DispatcherServlet
2. 调用处理器映射器  HandlerMapping，返回处理器执行链 HandlerExecutionChain
   包含拦截器 HandlerInterceptor 和 自己写的 Handler/Controller
3. 调用处理器适配器 HandlerAdapter，调用Handler，返回 ModelAndView
4. 调用视图解析器 ViewResovler，返回View
5. 视图渲染，将Model中的数据填充到View
6. 返回响应
** 相关注解
*** RequestMapping 作用在类上或方法上
1. RequestMapping(value = "/buy", method = RequestMethod.POST)
   method 默认支持 GET 和 POST
2. RequestMapping(params = "bookId")
   必须给bookId参数
   1. params支持简单的表达式
      1. !=param1
	 表示不能包含名为的参数
      2. param1 != value1
	 表示请求必须包含但值不为
      3. {"param1=value1", "param2"}
	 表示请求必须包含两个参数
3. 支持Ant风格资源地址
   1. ？匹配文件名中的一个字符
   2. * 匹配文件名中的任意字符
   3. ** 匹配多层路径
4. @RequestMapping(value = "/reg/{username}/{userid}")
   如何匹配方法的参数 @PathVariable("username") String name
5. RequestMapping 注意事项
   1. 映射的URL，不能重复
      @RequestMapping(value = "/hi") 即 /hi 路径不能有两个
   2. 简写形式 @PostMapping @GetMapping
   3. 表单请求的参数名要和目标方法的参数名保持一致
      网址参数名 ?email=xxx 和 方法的参数名 String email 一致 
*** RequestParam 作用在方法的参数上
获取参数值
1. @RequestMapping(value="name", required=fanse)
   1. @RequestParam表示会接收提交的参数
   2. value="name" 表示提交的参数名是name
   3. required=false 表示该参数可以没有，默认是true，表示必领有这个参数
** REST
*** 说明
1. 即 Representational State Transfer 表现层状态转化
2. GET 用来获取资源 POST 用来新建资源 PUT 用来更新资源 DELETE 用来删除资源
3. 当前浏览器只支持post/get请求，因此为了得到put/delete的请求方式需要使用Spring提供的 HiddenHttpMethodFilter 过滤器进行转换
*** Rest应用案例
web.xml
#+begin_src xml
  <filter>
    <servlet-name>hiddenHttpMethodFilter</servlet-name>
    <servlet-class>org.springframework.web.filter.HiddenHttpMethodFilter</servlet-class>
  </filter>
  
  <filter-mapping>
    <servlet-name>hiddenHttpMethodFilter</servlet-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
#+end_src
springDispatcherServlet-servlet.xml
#+begin_src xml
  <!-- 能支持SpringMVC高级功能，比如JSR303校验，映射动态请求 -->
  <mvc:annotation-driven></imvc:annotation-driven>
  <!-- 将SpringMVC不能处理的请求交给Tomcat，比如请求css.js等 -->
  <mvc:default-servlet-handler/>
#+end_src
*** 发送DELETE请求
使用删除超链接来提交隐藏表单
隐藏表单及超链接
#+begin_src html
  <a href="user/book/600" id="deleteBook">删除指定id的书</a>
  <form action="" method="post" id="hiddenForm">
      <input type="hidden" name="_method"/>
  </form>
#+end_src
使用jqery提交
#+begin_src js
  $("#deleteBook").click(function(){
      $("hiddenForm").attr("action, this.href");
      $(":hidden").val("DELETE");
      $("#hiddenForm").submit();
      return false; // 改变点击超链接的行为，不再提交
  })
#+end_src
*** 解决jsp只支持GET POST
return "redirect:/user/success";
** 获取请求头
RequestHeader 作用于方法参数上
1. @RequestHeader("Accept-Encoding") 
** 获取Java对象
1. 方法的形参用对应的类型指定即可
2. 如果是属性是对象，通过 字段名.字段名 获取，
3. 如果提交的数据的参数名和对象的字段名不匹配，则对象的属性就是null
** 使用Servlet API
1. 使用servlet api，需要引入tomcat/lib下的servlet-apiapiapi,jar
2. 直接写在方法声明上，HttpservletRequest HttpServletResponse
3. 除了 HttpServletRequest，HttpServletResponse还可以其它对象也可以这样的形式获取
4. HttpSession InputStream OutputStream Reader Writer
5. 其中一些对象也可以通过 HttpServletRequest/HttpServletResponse对象获取，比如Session对象，既可以通过参数传入，也可以可以通过requesst.getSession()获取，效果一样，推荐使用参数形式传入，更加简单明了
** 模型数据-放入Request域
1. 说明，控制器/处理器中获取的数据 如何放入request域，然后在前端（VUE/JSP……）取出显示
*** 模型数据-默认机制放入request域
1. 将提交的数据，封装到java对象，springmvc会自动的将其放入到request域
*** 模型数据-HttpServletRequest使用
requist.setAttribute("address", "beijing")
**** 分析一下springmvc默认存放对象到request域中，属性名是
属性名是类名/类型名，首字母小写，所以 =前端从request域获得数据的变量名与后端的变量名无关=
*** 模型数据-Map的使用
map对象定义在方法的参数中
**** 原理分析： springmvc会遍历map，然后将map的k-v，存放到request域
*** 模型数据-ModelAndView使用
#+begin_src java
  ModelAndView modelAndView = new ModelAndView();
  modelAndView.addObject("address", "shanghai");
  // 这里指定跳转的视图名称
  modelAndView.setViewName("vote_ok");
  return modelAndView;
#+end_src
**** 使用注意事项
1. 从本质看，请求响应的方法return "xx"，是返回了一个字符串，其实本质是返回了一个ModelAndView对象，只是默认被封装起来的
2. ModelAndView既可以包含model数据，也可以包含视图信息
3. ModelAndView对象的addObject方法可以添加 key-val数据，默认在request域中
4. ModelAndView对象setViewName方法可以指定视图名称
** 模型数据-数据放入Session域
将session对象放入方法的参数中
** 模型数据-@ModelAttribute
*** 基本说明
开发中，有时需要使用某个前置方法(比如prepareXxx(),方法名由程序员定)给目标方法准备一个模型对象
1. @ModelAttribute 注解可以实现这样的需求
2. 在某个方法上，增加了@ModelAttribute注解后
3. 那么在调用该Handler的任何一个方法时，都会先调用这个方法。类似于AOP的前置通知
*** @ModelAttribute最佳实践
● 修改用户信息(就是经典的使用这种机制的应用)，流程如下:
1. 在修改前，在前置方法中从数据库查出这个用户
2. 在修改方法(目标方法)中，可以使用前置方法从数据库查询的用户
3. 如果表单中对用户的某个属性修改了，则以新的数据为准，如果没有修改，则以数据库的信息为准，比如，用户的某个属性不能修改，就保持原来的值
** 视图和视图解析器
*** 基本介绍
1. 在springMVC中的目标方法最终返回都是一个视图(有各种视图).
2. 返回的视图都会由一个视图解析器来处理(视图解析器有很多种)
*** 为什么需要自定义视图
1. 在默认情况下，我们都是返回默认的视图, 然后返回的视图交由 SpringMVC的InternalResourceViewResolver 视图解析器器来处理的
2. 在实际开发中，我们有时需要自定义视图, 这样可以满足更多更复杂的需求。
*** 自定义视图实例-实现
#+begin_src java
  @Component(value="myView")
  public class MyView extends AbstractView {
      @Override
      protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response){
  	sout("进入到自己的视图");
  	request.getRequestDispatcher("/WEB-INF/pagers/my_view.jsp").forward(request, response);
      }
  }
#+end_src
**** 配置自定义视图解析器
#+begin_src xml
  <!--
      1. BeanNameViewResolver可以去解析我们自定义的视图  
      2. order表示视图解析器执行的顺序，值越小，优先级越高
      3. order 的默认值是 最低优先级，值为 Integer.MAX_VALUE
  -->
    <bean class="org.springframework.web.servlet.view.BeanNameViewResolver">
        <property name="order" value="99"/>
    </bean>
#+end_src
*** 自定义视图-工作流程
1. SpringMVC 调用目标方法,返回自定义View在IOC容器中的名字
2. SpringMVC 调用 BeanNameViewResolver 解析视图:从IOC 容器中获取 返回id 值对应的bean,即自定义的View的对象
3. SpringMVC 调用自定义视图的 renderMergedOutputModel方法渲染视图
4. 说明:如果在SpringMVC 调用目标方法, 返回自定义View在IOC容器中的 id, 不存在，则仍然按照默认的视图处理器机制处理.
*** 多个视图解析器执行流程
1. 当自定义视图解析器的优先级高于默认视图解析器，如果自定义视图解析不存在，会接着调用默认视图解析器
   原理
   1. 当ioc容器找不到自定义视图，会返回null，接着回到DispatcherServlet，会再次进入for循环
   2. 在前端控制器有一个属性叫做viewResolvers，保存多个视图解析器，是一个ArrayList，优先级高的排名在前
   3. 取出第二个视图解析器，此时 viewResolver 已经切换成了默认的视图解析器，默认视图解析器包含 prefix suffix
      提问：默认视图解析器是在哪拿到的前缀 后缀
   4. 解析器执行，返回了view，属性url是根据前后缀拼接，如果页面不存在，就会出现404
2. 提问：如果默认视图解析器优先级高，但没有找到页面，会不会走自定义视图解析器呢
   不会，因为默认视图解析器优先级高，所以成为viewResolvers的第一个元素，因为默认视图解析器始终会返回视图，不管url指向的页面是否存在，当视图不为空，就会退出循环
** 指定请求转发或者重定向
1. 默认返回的方式是请求转发，然后用视图处理器进行处理，比如在目标方法中这样写
   return "ok";
2. 也可以在目标方法直接指定重定向或转发url地址
3. 如果指定重定向，不能定向/WEB-INF目录中
* 自己实现SpringMVC
** 阶段1：开发DispatcherServlet
1. DispatcherServlet extends HttpServlet
2. 创建springmvc.xml 充当原生的applicationContext-mvc.xml文件（就是；spring的 容器配置文件）
3. 在web.xml配置DispatcherServlet拦截所有请求并且自动启动
4. 给DispatcherServlet配置参数，指定要操作的spring容器配置文件 contextConfigLocation
** 阶段2：完成客户端/浏览器可以请求控制层
*** 创建自己的Controller和自定义注解
1. 包springmvc 放置 springmvc底层机制（servlet、注解，解析工具），外边 放 工程相关的文件
2. 在controller包建立MonsterController，方法的参数是request response，给浏览器回一句话printWriter.wriite("<h1>妖怪列表信息</h1>")，增加注解 @Controller 和 @RequestMapping(value = "/list/monster")
*** 配置springmvc.xml
1. 充当springmvc的配置文件
2. 指定要扫描的基本包以及子包 component-scan base-package
*** 编写XMLParer工具类，可以解析springmvc.xml，取得扫描包
#+begin_src java
  inputStream = XmlParser.class.getClassLoader().getResourceAsStream(xml文件名);
  document = saxReader.read(inputStream);
#+end_src
*** 开发WebApplicationContext，充当Spring容器-得到扫描包的全路径列表
1. 在springmvc/context包，建立 WebApplicationContext
   1. 属性 classFullPathList
      保存扫描包/子包的类的全 路径
   2. 调用XMLParer，得到扫描包，再得到全路径，封装到init方法
2. 在 DispatcherServlet的 init方法中，调用 WebApplicationContext的 init方法
3. 提问：两个 init方法，有什么区别
   1. DispatcherServlet是servlet，它的init方法，会在启动tomcat时调用，并且只会调用一次
   2. WebApplicationContext的 init方法只是普通方法
*** 开发WebApplicationContext，充当Spring容器-实例化对象到容器中
1. 遍历扫描包路径的文件，如果是文件夹，需要递归
   scanPackage(pack + "." + f.getName());
   解释：
   1. scanPackage是 WebApplicationContext的方法，也是递归调用的方法
   2. pack 是扫描包的扫描包名 比如com.xxx
   3. f是扫描包路径下的文件夹
2. 如果是文件，拼接包名，得到全类名
   pack + "." + f.getName().replaceAll(".class", "");
3. 将全类名放入容器
4. 遍历全类名，根据全类名反射，将包含 @controller的类实例化进ioc容器
5. key为类名首字母小写，value为bean对象
   =类名：clazz.getSimpleName()=
*** 完成请求URL和控制器方法的映射关系
1. 定义 Handler 类用来保存url和控制器方法的映射关系
   属性：
   1. url
   2. controller
   3. method
2. 遍历map（ioc容器），取得bean对象的class，拿到每个bean的方法对象数组
3. 遍历所有方法，得到含有@RequestMapping的值
4. 创建Handler对象，将 url，控制器对象，方法对象放入
5. 将Handler对象放入handlerList集合
*** 完成DispatcherServlet分发请求到对应的控制器方法
1. 先获取用户请求的uri
   request.getRequestURI();
2. 根据uri找到handler
3. 有一个问题，uri会携带一个工程路径，而handler在保存时，没有加上，有2个解决方法
   1. 就是在保存handler时加上工程路径
   2. 修改idea的工程路径为/，这样更简洁
4. 执行分发
   handler.getMethod().invoke(handler.getController(), request, response);
** 阶段3：从web.xml动态获取springmvc.xml
1. 利用servletConfig，获得xml文件中配置的配置文件的位置
2. 通过配置文件，从DispatcherServlet传递配置文件位置到WebApplicationContext
** 阶段4：完成自定义@Service注解功能
1. 定义@Service
2. 遍历全类名，根据全类名反射，将包含 @Service的类实例化进ioc容器
3. 获取@Service的value，作为beanName
4. 如果beanName为空
5. 原生的spring可以通过接口名和类名来注入ioc容器
   1. 得到所有接口名
   2. 遍历接口，然后通过多个接口名来注入
   3. 获得接口名，反射创建service实现类，存入ioc容器
   4. 再存一份通过类名首字母小写来获取的
** 阶段5：完成Spring容器对象的自动装配 @Autowried
1. 定义 @AutoWired
2. 遍历ioc容器中的所有注入的bean对象，然后获取到bean的所有字段/属性，判断是否需要装配
   1. 遍历ioc容器，获取bean的所有字段/属性
   2. 遍历所有字段，判断字段是否有@AutoWired
   3. 获取@AutoWired
   4. 如果@AutoWired设置value来进行装配
   5. 防止属性是private，需要暴力破解
      declaredField.setAccesdible(true);
   6. 装配属性
      declaredField.set(bean, ioc.get(beanName));
      1. bean：当前字段所对应的bean，是controller
      2. ioc.get(beanName)：装配的目标，是service
	 1. beanName：@AutoWired的value
   7. 如果@AutoWired没有设置value，以字段类型的首字母小写，作为名字来进行装配
      #+begin_src java
	// 得到字段的类型
	type = declaredField.getType();
	type.getSimpleName();
      #+end_src
** 阶段6：完成控制器方法获取参数 @RequestParam
*** 封装HttpServletRequest和HttpservletResponse到参数数组
1. 得到目标方法的所有形参参数信息（数组）
   parameterTypes = handler.getMethod().getParameterTypes();
2. 创建一个参数数组（对应实参数组），在后面调用目标方法时，会使用到
   params = new Object[parameterTypes.lengh];
3. 遍历parameterTypes形参数组, 根据形参数组信息，将实参填充到实参数组
#+begin_src java
  for(int i = 0; i < parameterTypes.length; i++) {
      // 取出每一个形参类型
      Class<?> parameterType = parameterTypes[i];
      // 如果这个形参是HttpServletRequest, 将request填充到params
      if("HttpServletRequest".equals(parameterType.getSimpleName())){
  	// 形参在第几个位置，实参就在第几个位置，形参和实参的位置一一对应
  	// request是servlet的参数
  	params[i] = request;
      }else if("HttpServletResponse".equals(parameterType.getSimpleName())){
  	params[i] = response;
      }
  }
#+end_src
*** 封装Http请求数据到参数数组
1. 增加 @RequestParam
   1. @Taarget(ElementType.PARAMETER)
      指定标注在目标方法的参数上
2. 将http请求参数封装到params数组中，要注意填充实参的时候，顺序问题
   1. 获取http请求的参数
      Map<String, String[]> parameterMap = request.getParmeterMap();
      Map<String, String[]>解读：
      1. String：表示http请求的参数名
      2. String[]：表示httpp请求的参数值
   2. 遍历parameterMap 将请求参数，得到参数名和参数值
   3. 按照顺序填充到实参数组
* MyBatis 
** 配置文件
1. mybatis-config.xml
   1. 配置数据库连接/数据源
   2. 管理XXMapper.xml
2. XXMapper.xml（比如 MonsterMapper.xml）
   1. 配置SQL，完成对monster表的crud
** Java操作DB
1. MonsterMapper.java接口 声明方法crud
   1. 方法实现可以是注解方式
   2. 方法也可以在对应的MonsterMapper.xml去完成
2. 先创建Monster对象
3. 通过MyBatis的mybatis-config文件获取到SessionFactory对象(可以理解成是连接池)
4. 通过SessionFactory对象获取到SqlSession(可以理解成是连接)
5. 获取到MonsterMapper的对象
6. 调用MonsterMapper的方法，完成对monster表的各种操作
**  MonsterMapper.xml
#+begin_src xml
  <mapper  namespace="接口的全类名">
    <insert id="接口里面声明的方法" parameterType="方法形参类型的全类名">
      INSERT INTO 
      `monster` (`age`, `birthday`, `email`, `gender`, `name`, `salary`) 
      VALUE (#{age}, #{birthday}, #{email}, #{gender}, #{gender}, #{name}, #{salary})
    </insert>
  </mapper>
#+end_src
** 添加语句，建议表名和字段名带上反引号
** mybatis-config.xml
#+begin_src xml
  <mappers>
    <mapper resource="通过菜单 Path from source root(全路径，类似全类名，但分隔符号是/)"/>
  </mappers>
#+end_src
** 报错：找不到MonsterMapper.xml
pom.xml
#+begin_src xml
  <!--    将资源文件，在build项目时导出到对应的target目录下-->
    <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                </includes>
            </resource>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.xml</include>
                    <include>**/*.properties</include>
                </includes>
            </resource>
        </resources>
    </build>
    
#+end_src
