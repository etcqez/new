* sql执行流程
先查询缓存，如果没有命中，进入解析器，进行词法解析，生成解析树，通过查询优化器进行优化，生成执行计划
* myisam和innodb的对比
innodb支持外键、事务、支持行锁，锁定时只锁一行，不对其它行有影响，适合高 并发的操作，myisam只缓存索引，不缓存真实数据，myisam内存占用更少
* 主键索引(聚簇索引)和二级索引
主键索引：主键当作索引，数据紧跟其后
二级索引：非主键当索引，后面仅仅只跟主键，通过回表查询其它字段
* hash结构效率高，那为什么索引结构要设计成树型呢？
1. hash索引仅能满足(=) (<>) 和 in 查询，如果进行范围查询，哈希型索引，时间复杂度会退化为O(n)，而树型的"有序"特性，依然能够保持O(log2N)的高效率
2. hash索引还有一个缺陷，数据的存储是没有顺序的，在order by的情况下，使用hash索引还需林对数据进行重新排序
3. 对于联合索引的情况，hash值是将联合索引合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询
4. 索引列的重复值如果过多，效率会降低
* B+树的存储能力如何？为何说一般查找行记录，最多只需1～3次磁盘IO
因为目录页存储的是主键值和地址值，一个页大概存储16KB/(8B+8B)=1K个键值，假设有三层，第3层存储表中的记录，假设也为3层，可以维护10^3*10^3*10^3=10亿条记录
B+Tree的高度一般都在2～4层，根节点常驻内存，也就是只需要1～3次磁盘io
* B+树和B树的差异在于以下几点
B+树数据全在叶子节点上，B树数据每个节点都有
* B+树的中间节点不直接存储数据，这样的好处有什么？
b+树的中间节点只存储主键，还有页号，不存储完整的记录，B+树存放的目录项更多，叉更多，存储的数据更多
* mysql的优化
1. 设置隐藏索引，看看前后对比
2. 创建联合索引，务必把范围涉及到的字段写在最后
* 哪些情况适合创建索引
1. 字段的数值有唯一性的限制
2. 频繁作为WHERE查询条件的字段
3. 经常GROUP BY 和 ORDER BY的列
4. UPDATE、DELETE的WHERE条件列
5. DISTINCT字段需要创建索引
6. 多表JOIN连接操作时，创建索引注意事项
   连接表的数据尽量不要超过3张
   对WHERE条件创建索引
   对用于 =连接的字段= 创建索引，并且该字段在多张表中的类型必须一致
7. 使用列的 类型小的创建索引(以整数为例，有TINYINT、MEDIUNMINT、INT、BIGINT等)
8. 使用字符前缀创建索引
* 最佳左前缀法则
即最左优先，在检索数据时从联合索引的最左边开始匹配
* 索引失效的情况
1. 类型转换导致索引失效
2. 范围条件右边的列索引失效
3. 不等于和 is not null 索引失效
4. like以通配符%开头索引失效
5. or前后存在非索引的列，索引失效
* join语句原理
1. simple nested-loop join(简单嵌套循环连接)
   驱动表A中的每一条记录与被驱动表B的记录进行判断
2. index nested-loop join)
   被驱动表必须有索引
3. block nested-loop join(块嵌套循环连接)
   引入join buffer缓冲区，一块一块获取驱动表数据，被驱动表的每一条记录和join buffer中的所有驱动表记录进行匹配
* 双路排序和单路排序
1. 双路排序
   字面意思就是进行两次扫描磁盘
   比如说order age，首先找到order by 字段age，加载到内存当中，在内存中针对age进行排序，排完序后，再能过age找到表中对应的完整的一条数据，再把完整数据取到内存当中
2. 单路排序
   只扫描一次，读取所有列
** 优化策略
1. 提高sort_buffer_size
2. 提高max_length_for_sort_data(如果字段短，用单路)
* 覆盖索引
如果查询的字段就是联合索引，最多再配个主键id，不需要回表了，即使%在最前面导致索引失效，也会使用索引
 好处：避免回表，随机io变成顺序io
* 索引条件下推(index_condition_pushdown)
如果字段存在于联合索引，即使索引失效，会直接判断该字段而不回表
* exist和in的区分
小表驱动大表用exist，从小表找到结果再与大表比较，使用in
* count(*)和count(具体字段)
1. count(*)和count(1)基本一样，但是在不同的存储引擎是有区别的
2. count(具体字段)要尽量采用二级索引，因为聚簇索引包含所有字段，而二级索引是放着索引和主键，数据量更小
* 关于select(*)
1. 转换成所有列名通过查询数据字典
2. 无法使用覆盖索引
* limit 1 对优化的影响
如果是全表描描sql语句，当查到一条结果时就不会继续，如果对字段建立了唯一索引，就没必要了
* 淘宝数据库的主键如何设计
1. 主键设计应该至少是全局唯一且是单调递增
2. UUID的特点全局唯一，占用36字节，数据无序
3. 将UUIO时间高低位互换，则时间就是单调递增的
4. uuid_to_bin函数将UUID转换成单调递增的UUID
* 范式
** 第一范式
确保每个字段的值必须具有原子性，不可再次拆分
** 第二范式
得有主键，所有非主键，都必须完全依赖主键，不能只依赖主键的一部分
** 第三范式
非主键字段必须相互独立
** 巴斯范式
主键中的某个属性被候选键中的某个属性所决定了
